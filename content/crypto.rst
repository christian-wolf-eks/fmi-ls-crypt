.. _signatures:

Cryptography and trust anchor
#############################

.. note:: Should we allow only cert based/PKI approach or also web of trust? Does it even make a difference here?

This layered standard allows using multiple signatures simultaneously.
If one of the signatures can be verified, the FMU should be considered valid.

.. warning:: One or all for validity? SHOULD / MUST?

The individual signatures must be stored in the ``signatures`` tag in the ``crypto.xml`` file.
The ordering of the signatures is irrelevant.
The type of the signature is defined by the XML tag of the signature.

.. note::
    Example of a ``signatures`` XML tag with three x509-based signatures and one PGP-based signature

    .. code-block:: XML

        <signatures>
            <x509-signature>...</x509-signature>
            <x509-signature>...</x509-signature>
            <pgp-signature>...</pgp-signature>
            <x509-signature>...</x509-signature>
        </signatures>

Public Key Infrastructure (PKI) using x509 certificates
=======================================================

.. note:: 
    The [IEC9594]_ is the standardized way to handle certificates.
    This is typically done my means of a so-called public key infrastructure.

    The base idea is to create a chain of certificates.
    Each certificate is signed by its parent certificate.
    As a result, a tree of certificates is created.
    The leaf certificates are the actual certificates that are used for whatever task at hand.
    The intermediate certificates are mainly for deployment and management purposes.

    The root certificate is the parent of all other certificates of a tree.
    In order to trust a certain certificate, the user must trust the root certificate.
    Once trust in the root certificate is established, the user can follow the chain of certificates and check the certificates for valid signatures.
    That way, the user can establish trust in a cryptographic way in any leaf certificate when trusting the root certificate.

    Typically, the root certificates are generated by official agencies of institutions called Root Certificate Authority (Root CA).
    These root certificates are installed statically into the software or even the operating system.
    In order to obtain a certain certificate one must authenticate and provide authorization to a root CA.
    The root CA will then issue a signed certificate.
    Intermediate certificates are called intermediate CAs.
    They have two main use cases:

    - Technical to keep root private key protected:
      The root certificate's private key is very vulnerable.
      To avoid compromising it, it is typically managed in an air-gapped system.
      To allow for live and easy certificate generation, a single intermediate CA is used by root CAs to sign the actual certificates.
    - Per organization (unit) certificates:
      One benefit of the structured certificate creation and verification process is that it can be somewhat decentralized.
      Each company can create a local intermediate CA.
      Of course, the root CA must only sign the intermediate CA if the company is to be trusted.
      (Using x509 extensions a certain restriction can be imposed, but this is not part of this layered standard.)
      This way, the organization can issue certificates for their own usage.
      For example, a component supplier could create certificates for all generated FMUs and use them to sign the FMUs individually.

A signature using a x509 certificate must be indicated by an XML tag ``x509-signature``.
The tag must have the following children:

- A tag ``x509-chain`` that represents the chain of certificates to sign/verify the FMU
- A tag ``signature`` that holds the actual signature

.. note::
    Example

    .. code-block:: XML

        <x509-signature>
            <x509-chain>
                <chain-link>
                    AAABBBBDDDCCCC
                </chain-link>
                <chain-link>
                    0000111122223333
                </chain-link>
            </x509-chain>
            <signature>
                44556677
            </signature>
        </x509-signature>

Storage of the cryptographic chain
----------------------------------

All certificates must be stored in PEM format.
The header and footer lines (``===== BEGIN CERTIFICATE ======`` and ``====== END CERTIFICATE ======``) must be dropped.

A single chain of certificates must be provided within the XML tag ``x509-chain``.
Each certificate in the chain must be enclosed in a ``chain-link`` XML tag.
In the ``chain-link`` tag, only the content of the certificate must be provided without the header/footer lines.
The certificate content can be broken into multiple lines and whitespace can be added for indentation.

The ``chain-link`` entries must be provided in the order of the certificate chain:
each certificate in the chain signs the certificate in the next ``chain-link`` tag.
Only the last certificate in the chain is the leaf certificate and must not sign any other certificate.

The root certificate as very first certificate in the chain should not be present in the XML file.

.. warning::
    Should the root Cert be in the XML?

.. note::
    As XML does not take whitespace into account, the newlines in the certificate body might or might not be present.
    In any case, these are not parsed in reading the XML file.
    As the content is base64-encoded, this is no problem. The parser just needs to be aware of this.

.. note::
    Here is an example XML snippet of a certificate chain:

    .. code-block:: xml

        <x509-chain>
            <chain-link>
                AAABBBBDDDCCCC
            </chain-link>
            <chain-link>
                BBBCCCDDDEEEFF
            </chain-link>
        </x509-chain>
        
    .. warning::
        T.B.D

Signature of the hashes
-----------------------

The tag ``signature`` must contain the base64-encoded [RFC4648]_ signature of the total hash.

The leaf certificate's private key must not be part of the distributed FMU.
It must be used while building the FMU according to this layered standard to sign the total hash as defined in :ref:`total-hash`.

.. note::
    The signature of the total hash can be checked this way to be genuine.
    As the total hash was calculated from the individual hashes, any change in any file will with very high probability lead to a change in the individual hash string and thus in the total hash.
    Using the cryptographic signature, the user can be rather sure that the files are not changed intentionally or non-intentionally compared to the ones when signed.

Tasks of the importer
---------------------

.. warning:: How to handle shortened certificate chains?

    If the certificate chain contains more certificates (another root CA), should this be accepted or rejected?

In order to check the cryptographic signature, the importer must first load the certificate chain as provided in the ``x509-chain`` XML tag specified.
Each certificate must be checked individually for validity, this is

- Certificate has not expired (``notAfter``)
- Certificate is already active (``notBefore``)
- Certificate is signed by a trusted certificate (parent certificate in the chain or in registered root CAs)
- Certificate subject must comply with parent's name constraints
- For intermediate certificates: Certificate name constraints must not soften name constraints imposed by parent certificate
- Additional checks may be added by the importer

Once, trust in a leaf certificate has been established, the certificate's public key can be extracted.
The importer must decode the base64-encoded signature and use the private key to verify the signature of the total hash.
In order to report an FMU as signed and thus secure, the importer must also check all hashes as described in the section :ref:`Checking of the hashes <check-hashes>`.

.. note::

    This layered standard intentionally does not specify what certificates should be considered as root certificates or as trusted.
    It is up to the importer to provide the user a way to specify which FMUs to trust and which are not to be trusted.

    For example, the user might only trust these FMUs that have a certain name constraint fulfilled.
    Then, there could be a whitelist of companies that are allowed to send in certificates.
    Then, the certificates' ``O`` (organization) subject must match one of these whitelist entries to be accepted.

    The actual policy of the certificate generation however should not be part of the layered standard for FMI.
    Instead, the exact policy should be published and enforced as a parallel publication depending on the needs at hand.

.. warning:: Open points

    - Trust anchor? Bisher nur Vertrauen in *ein Zertifikat*, wer kann das erstellen? Darf er das?
    - Certification policy und name constraints?
    - Welchen Firmen/CAs traue ich?

Web of Trust (WoT)
==================

.. note:: T.B.D.


